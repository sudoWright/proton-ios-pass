// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vault_v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum ProtonPassVaultV1_VaultIcon: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case iconUnspecified // = 0
    case iconCustom // = 1
    case icon1 // = 2
    case icon2 // = 3
    case icon3 // = 4
    case icon4 // = 5
    case icon5 // = 6
    case icon6 // = 7
    case icon7 // = 8
    case icon8 // = 9
    case icon9 // = 10
    case icon10 // = 11
    case icon11 // = 12
    case icon12 // = 13
    case icon13 // = 14
    case icon14 // = 15
    case icon15 // = 16
    case icon16 // = 17
    case icon17 // = 18
    case icon18 // = 19
    case icon19 // = 20
    case icon20 // = 21
    case icon21 // = 22
    case icon22 // = 23
    case icon23 // = 24
    case icon24 // = 25
    case icon25 // = 26
    case icon26 // = 27
    case icon27 // = 28
    case icon28 // = 29
    case icon29 // = 30
    case icon30 // = 31
    case UNRECOGNIZED(Int)

    public init() {
        self = .iconUnspecified
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .iconUnspecified
        case 1: self = .iconCustom
        case 2: self = .icon1
        case 3: self = .icon2
        case 4: self = .icon3
        case 5: self = .icon4
        case 6: self = .icon5
        case 7: self = .icon6
        case 8: self = .icon7
        case 9: self = .icon8
        case 10: self = .icon9
        case 11: self = .icon10
        case 12: self = .icon11
        case 13: self = .icon12
        case 14: self = .icon13
        case 15: self = .icon14
        case 16: self = .icon15
        case 17: self = .icon16
        case 18: self = .icon17
        case 19: self = .icon18
        case 20: self = .icon19
        case 21: self = .icon20
        case 22: self = .icon21
        case 23: self = .icon22
        case 24: self = .icon23
        case 25: self = .icon24
        case 26: self = .icon25
        case 27: self = .icon26
        case 28: self = .icon27
        case 29: self = .icon28
        case 30: self = .icon29
        case 31: self = .icon30
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .iconUnspecified: return 0
        case .iconCustom: return 1
        case .icon1: return 2
        case .icon2: return 3
        case .icon3: return 4
        case .icon4: return 5
        case .icon5: return 6
        case .icon6: return 7
        case .icon7: return 8
        case .icon8: return 9
        case .icon9: return 10
        case .icon10: return 11
        case .icon11: return 12
        case .icon12: return 13
        case .icon13: return 14
        case .icon14: return 15
        case .icon15: return 16
        case .icon16: return 17
        case .icon17: return 18
        case .icon18: return 19
        case .icon19: return 20
        case .icon20: return 21
        case .icon21: return 22
        case .icon22: return 23
        case .icon23: return 24
        case .icon24: return 25
        case .icon25: return 26
        case .icon26: return 27
        case .icon27: return 28
        case .icon28: return 29
        case .icon29: return 30
        case .icon30: return 31
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension ProtonPassVaultV1_VaultIcon: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static var allCases: [ProtonPassVaultV1_VaultIcon] = [
        .iconUnspecified,
        .iconCustom,
        .icon1,
        .icon2,
        .icon3,
        .icon4,
        .icon5,
        .icon6,
        .icon7,
        .icon8,
        .icon9,
        .icon10,
        .icon11,
        .icon12,
        .icon13,
        .icon14,
        .icon15,
        .icon16,
        .icon17,
        .icon18,
        .icon19,
        .icon20,
        .icon21,
        .icon22,
        .icon23,
        .icon24,
        .icon25,
        .icon26,
        .icon27,
        .icon28,
        .icon29,
        .icon30
    ]
}

#endif // swift(>=4.2)

public enum ProtonPassVaultV1_VaultColor: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case colorUnspecified // = 0
    case colorCustom // = 1
    case color1 // = 2
    case color2 // = 3
    case color3 // = 4
    case color4 // = 5
    case color5 // = 6
    case color6 // = 7
    case color7 // = 8
    case color8 // = 9
    case color9 // = 10
    case color10 // = 11
    case UNRECOGNIZED(Int)

    public init() {
        self = .colorUnspecified
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .colorUnspecified
        case 1: self = .colorCustom
        case 2: self = .color1
        case 3: self = .color2
        case 4: self = .color3
        case 5: self = .color4
        case 6: self = .color5
        case 7: self = .color6
        case 8: self = .color7
        case 9: self = .color8
        case 10: self = .color9
        case 11: self = .color10
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .colorUnspecified: return 0
        case .colorCustom: return 1
        case .color1: return 2
        case .color2: return 3
        case .color3: return 4
        case .color4: return 5
        case .color5: return 6
        case .color6: return 7
        case .color7: return 8
        case .color8: return 9
        case .color9: return 10
        case .color10: return 11
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension ProtonPassVaultV1_VaultColor: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static var allCases: [ProtonPassVaultV1_VaultColor] = [
        .colorUnspecified,
        .colorCustom,
        .color1,
        .color2,
        .color3,
        .color4,
        .color5,
        .color6,
        .color7,
        .color8,
        .color9,
        .color10
    ]
}

#endif // swift(>=4.2)

public struct ProtonPassVaultV1_VaultDisplayPreferences {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var icon: ProtonPassVaultV1_VaultIcon = .iconUnspecified

    public var color: ProtonPassVaultV1_VaultColor = .colorUnspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct ProtonPassVaultV1_Vault {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = .init()

    public var description_p: String = .init()

    public var display: ProtonPassVaultV1_VaultDisplayPreferences {
        get { _display ?? ProtonPassVaultV1_VaultDisplayPreferences() }
        set { _display = newValue }
    }

    /// Returns true if `display` has been explicitly set.
    public var hasDisplay: Bool { _display != nil }
    /// Clears the value of `display`. Subsequent reads from it will return its default value.
    public mutating func clearDisplay() { _display = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _display: ProtonPassVaultV1_VaultDisplayPreferences?
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ProtonPassVaultV1_VaultIcon: @unchecked Sendable {}
extension ProtonPassVaultV1_VaultColor: @unchecked Sendable {}
extension ProtonPassVaultV1_VaultDisplayPreferences: @unchecked Sendable {}
extension ProtonPassVaultV1_Vault: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "proton_pass_vault_v1"

extension ProtonPassVaultV1_VaultIcon: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ICON_UNSPECIFIED"),
        1: .same(proto: "ICON_CUSTOM"),
        2: .same(proto: "ICON1"),
        3: .same(proto: "ICON2"),
        4: .same(proto: "ICON3"),
        5: .same(proto: "ICON4"),
        6: .same(proto: "ICON5"),
        7: .same(proto: "ICON6"),
        8: .same(proto: "ICON7"),
        9: .same(proto: "ICON8"),
        10: .same(proto: "ICON9"),
        11: .same(proto: "ICON10"),
        12: .same(proto: "ICON11"),
        13: .same(proto: "ICON12"),
        14: .same(proto: "ICON13"),
        15: .same(proto: "ICON14"),
        16: .same(proto: "ICON15"),
        17: .same(proto: "ICON16"),
        18: .same(proto: "ICON17"),
        19: .same(proto: "ICON18"),
        20: .same(proto: "ICON19"),
        21: .same(proto: "ICON20"),
        22: .same(proto: "ICON21"),
        23: .same(proto: "ICON22"),
        24: .same(proto: "ICON23"),
        25: .same(proto: "ICON24"),
        26: .same(proto: "ICON25"),
        27: .same(proto: "ICON26"),
        28: .same(proto: "ICON27"),
        29: .same(proto: "ICON28"),
        30: .same(proto: "ICON29"),
        31: .same(proto: "ICON30")
    ]
}

extension ProtonPassVaultV1_VaultColor: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "COLOR_UNSPECIFIED"),
        1: .same(proto: "COLOR_CUSTOM"),
        2: .same(proto: "COLOR1"),
        3: .same(proto: "COLOR2"),
        4: .same(proto: "COLOR3"),
        5: .same(proto: "COLOR4"),
        6: .same(proto: "COLOR5"),
        7: .same(proto: "COLOR6"),
        8: .same(proto: "COLOR7"),
        9: .same(proto: "COLOR8"),
        10: .same(proto: "COLOR9"),
        11: .same(proto: "COLOR10")
    ]
}

extension ProtonPassVaultV1_VaultDisplayPreferences: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".VaultDisplayPreferences"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "icon"),
        2: .same(proto: "color")
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &icon)
            case 2: try decoder.decodeSingularEnumField(value: &color)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if icon != .iconUnspecified {
            try visitor.visitSingularEnumField(value: icon, fieldNumber: 1)
        }
        if color != .colorUnspecified {
            try visitor.visitSingularEnumField(value: color, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: ProtonPassVaultV1_VaultDisplayPreferences,
                           rhs: ProtonPassVaultV1_VaultDisplayPreferences) -> Bool {
        if lhs.icon != rhs.icon { return false }
        if lhs.color != rhs.color { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension ProtonPassVaultV1_Vault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Vault"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "description"),
        3: .same(proto: "display")
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &description_p)
            case 3: try decoder.decodeSingularMessageField(value: &_display)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        try { if let v = self._display {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: ProtonPassVaultV1_Vault, rhs: ProtonPassVaultV1_Vault) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs._display != rhs._display { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
